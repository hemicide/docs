# Конкурентность и параллелизм в GO

![alt text](image.png)

Горутины работают в одном адресном пространстве. Следовательно, доступ к общей памяти должен быть синхронизирован. Это можно сделать через пакет sync, но это крайне не рекомендуется. Вместо этого Go использует каналы для синхронизации горутин.

Управление стеком осуществляется автоматически. Сборщик мусора не управляет стеками. Вместо этого они освобождаются сразу после выхода горутины.

Горутины могут выполняться в нескольких потоках операционной системы. Горутины имеют временной интервал в потоках ОС, поэтому некоторое количество горутин может обслуживаться меньшим числом потоков ОС.

Существуют два стиля параллелизма: детерминированный (четко определенный порядок) и недетерминированный (блокировка / взаимное исключение, но неопределенный порядок). Горутины и каналы Go продвигают детерминированный параллелизм (например, каналы с одним отправителем и одним получателем).

---

## Переключение контекста

Кооперативная многозадачность - контекст переключается в тот момент когда текущая активная задача явно объявляет о том что она готова отдать контекст другой задаче. (есть риск что будут захвачены все вычислительные ресурсы и не даст выполнятся другим задачам)

Вытесняющаяя многозадачность - задачи управляются некоторым компонентом, который принудительно может ставить одни задачи на паузу и продолжать выполнение других (может быть неэффективным переключение контекста)

В GO существуется смешенный подход (планировщиком), но работает не в режиме runtime, а во время компиляции приложения.
Компилятор расставляет метки для переключения контекста в различным местах программы, основываясь на некоторых эвристиках о том что в таких местах программа скорее всего будет заблокирована.

Переключение контекста обычно происходит в местах:

- операции с сетью
- системные вызовы
- вызовы функций
- блокировки

> runtime.Goshed() - явно переключится на выполнение другой горутины

## Синхронизация потоков

- chan

## Синхронизация доступа к данным

Примитивы синхронизации:

- Mutex
- RWMutex
- Atomic - атомарные счетчики (низкоуровненвые примитивы синхронизации)
- sync.Map
- WaitGroup
- sync.Poll
- sync.Cond

### Mutex

1. Не встаривать Mutex в структуру:

```go

```

2. Не хранить ссылку на Mutex в поле структуры

```go

```

3. Методы которые блокируют и разблокируют Mutex должны иметь ссылчной ресивер

```go

```

4. RWMutex

## Состояние гонки

### race detector

```go
--race
```
